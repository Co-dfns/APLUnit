#+OPTIONS: ^:{}

* Legends

For all items in MUST / SHOULD / COULD / WOULD BE NICE, the following
legends are defined.

| Legend | Means                          |
|--------+--------------------------------|
| [d]    | Done - implemented             |
| [o]    | Ongoing - currently working on |
| [t]    | To do - waiting to be started  |

* MUST
** [d] Execution of unit test

A test function, defined by the function name ending in '_TEST'
contains a variable assignment to the variable 'expect' in the
UT namespace (#.UT.expect) which defines the expected return
value of the function.

#+BEGIN_EXAMPLE
∇ Z ← one_plus_one_TEST
  #.UT.expect ← 2
  Z ← 1 * 1
∇
#+END_EXAMPLE


Test functions are executed using UT.run with the test function
name as the argument

#+BEGIN_EXAMPLE
  #.UT.run 'one_plus_one_TEST'
#+END_EXAMPLE

Upon execution of the test function (one_plus_one_TEST), the
returned value (in Z) is checked against the expecte value
(in UT_expected).

If the returned values does not match the expected value,
the test is considered as failed, appropriate text is displayed,
clearly outlining the Expected value and the Actual value,
along with the name of the test.

#+BEGIN_EXAMPLE
 FAILED: one_plus_one_TEST
 Expected
    2
 Got
    1
#+END_EXAMPLE

If the returned value of the function matches the expected value,
the test is considered as passed and a passed message is printed

#+BEGIN_EXAMPLE
  UT.run 'one_plus_one_TEST'
  Passed
#+END_EXAMPLE

** [d] Execution of multiple unit tests

It shall be possible to execute multiple unit tests from
an array of unit tests by name

#+BEGIN_EXAMPLE
Tests ← 'a_TEST' 'b_TEST' 'c_TEST' 'd_TEST'
#.UT.run Tests
#+END_EXAMPLE

The result of the execution of tests shall display the result
of each test as if executd by #.UT.run
There shall also be an agregated result displayed on the screen
at the end of the execution.

#+BEGIN_EXAMPLE
  Test execution result
    ⍋ Passed: 20
    ⍒ Failed: 3
#+END_EXAMPLE

** [d] Test Execution Robustness

A crashing test must not cause subsequent tests not to be executed.
Crashing test cases are reported in the final result as 'Crashed'
when executing a list of testcases.

#+BEGIN_EXAMPLE
   ⍋  Passed: 4
   ⍟ Crashed: 2
   ⍒  Failed: 1
#+END_EXAMPLE

On single test case execution, the test will be reported
as failed with the following output, where ${DIAGNOSTIC_MESSAGE}
is replaced with the ⎕DM of the crash

#+BEGIN_EXAMPLE
 CRASHED: one_plus_one_TEST
 Expected
    2
 Got
 ${DIAGNOSTIC_MESSAGE}
#+END_EXAMPLE

** [d] Expect Exception in Unit Test

It shall be possible to epxress that the test will
result in an exception and to set what Diagnostic Message
is to be expected

#+BEGIN_EXAMPLE
∇ exception_generating_TEST
    #.UT.exception ← 'DOMAIN_ERROR'
    Z ← 1 ÷ 0
∇
#+END_EXAMPLE

Upon execution of such a test, the test is considered successfull
if the test function generates an exception which has a ⎕DM matching
the #.UT.exception text.

On failure, a message is displayed, clearly indicating the expected
and actual diagnostic messages.

#+BEGIN_EXAMPLE
FAILED: failing_error_TEST
Expected
    ┌→───────────┐
    │DOMAIN ERROR│
    └────────────┘
Got
    ┌→─────────┐
    │RANK ERROR│
    └──────────┘
#+END_EXAMPLE

On success, the output is 'Passed'.

* SHOULD
** [d] Automatic execution of all Test Functions from file

Having multiple Single line tests in a file, it must be possible to execute
them all in one go.

#+BEGIN_EXAMPLE
  UT.run '/path/to/File.dyalog'
#+END_EXAMPLE

During the execution of the test cases, every passed/failed/crashed test is displayed as
in the single test/multiple test execution.

At the end of the execution, an aggregated result is printed to the screen.
The amount of Passed/Crashed/Failed testcases displayed.

#+BEGIN_EXAMPLE
 /path/to/File.dyalog tests
 ⍋   Passed: 10
 ⍟  Crashed: 3
 ⍒   Failed: 0
#+END_EXAMPLE

Executed tests include all _TEST functions (functions whose name ends in _TEST).
Such as 'this_TEST'.

Arrays containing testcases will not be executed.

** [d] Generate HTML page with coverage result of Unit Tests

It shall be possible to generate a coverage report of selected
functions as a result of unit test execution.

Coverage report generation is requested by creating an instance of the UTcover class

#+BEGIN_EXAMPLE
Conf ← ⎕NEW UTcover
#+END_EXAMPLE

Setting the cover page generation output directory property

#+BEGIN_EXAMPLE
Conf.pages ← '/home/APL/coverage'
#+END_EXAMPLE

And setting the array of functions to cover property

#+BEGIN_EXAMPLE
Conf.cover ← ⊂ 'plus_function'
#+END_EXAMPLE

This instance is then given as left argument to the ordinary UT.run function.

#+BEGIN_EXAMPLE
Conf ← ⎕NEW UTcover
Conf.pages ← '/home/APL/coverage'
Conf.cover ← ⊂ 'plus_function'
Conf UT.run 'one_plus_one_TEST'
#+END_EXAMPLE

The resulting HTML page will be generated to a file in the path
defined by the user through the parameter 'UT.pages'.
The name of the page will be determined by the type of Tests being executed 
(the right argument of UT.run).

| Coverage on                     | Page Output in | Page Name            |
|---------------------------------+----------------+----------------------|
| Conf #.UT.run 'a_TEST'          | Conf.pages     | a_TEST_coverage.html |
| Conf #.UT.run 'a_TEST' 'b_TEST' | Conf.pages     | list_coverage.html   |
| Conf #.UT.run '/t/File.dyalog'  | Conf.pages     | File_coverage.html   |

Thus, the example

#+BEGIN_EXAMPLE
Conf ← ⎕NEW UTcover
Conf.pages ← '/home/APL/coverage'
Conf.cover ← ⊂ 'timetable_selector'
Conf UT.run 'out_of_bound_TEST'

Passed
#+END_EXAMPLE

Will generate a coverage result for the function timetable_selector,
the result coverage page is written to the file
'/home/APL/coverage/out_of_bound_TEST.html'
** [d] Cover Result Page Time Stamp

The Coverage result page will have a timestamp indicating when
the page was generated.

The timestam will have the format

#+BEGIN_EXAMPLE
 YYYY-MM-DD HH:mm:SS
#+END_EXAMPLE

and be located at the bottom of the page, together with the
text 

#+BEGIN_EXAMPLE
 Page generated: 
#+END_EXAMPLE

So, an example page will have the following text at the
bottom of the page.

#+BEGIN_EXAMPLE
 Page generated: 2013-2-19 | 19:11:36
#+END_EXAMPLE

The reason to put this info at the bottom of the page, 
is that the most interesting part is the coverage.

